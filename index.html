<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Leamah School Dodge Challenge</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Hidden form for Netlify to detect */
        .netlify-form-detector {
            display: none !important;
        }
        
        #data-form {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 30;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 400px;
        }
        
        #data-form h2 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        #data-form input {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }
        
        #data-form input:focus {
            outline: none;
            border-color: #4CAF50;
            transform: scale(1);
        }
        
        #data-form button {
            padding: 12px 20px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .submit-btn {
            background: #4CAF50;
            color: white;
            width: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .submit-btn:hover {
            background: #45a049;
        }
        
        .submit-btn:active {
            background: #388e3c;
            transform: scale(0.98);
        }
        
        .submit-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .form-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 25;
            display: none;
        }
        
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        .control-zone {
            position: absolute;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }
        
        #move-zone {
            left: 0;
            background: rgba(30, 150, 255, 0.1);
        }
        
        #shoot-zone {
            right: 0;
            background: rgba(255, 255, 0, 0.1);
        }
        
        .control-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Hidden form for Netlify to detect during build -->
    <form name="game-scores" netlify netlify-honeypot="bot-field" hidden class="netlify-form-detector">
        <input type="text" name="bot-field" />
        <input type="text" name="facebook-username" />
        <input type="text" name="score" />
        <input type="text" name="grade" />
        <input type="text" name="timestamp" />
        <input type="text" name="game-session" />
    </form>
    
    <div class="form-overlay" id="form-overlay"></div>
    
    <div id="data-form">
        <h2>üèÜ Save Your Score!</h2>
        <div>Final Score: <span id="final-score">0</span> | Grade: <span id="final-grade">8</span></div>
        
        <form id="score-form">
            <!-- User input field with mobile-specific attributes -->
            <input type="text" 
                   name="facebook-username" 
                   id="facebook-username" 
                   placeholder="Enter your Facebook username" 
                   required
                   autocomplete="off"
                   autocorrect="off"
                   autocapitalize="none"
                   spellcheck="false"
                   inputmode="text">
            
            <div style="font-size: 12px; color: #666; margin: 10px 0; line-height: 1.4;">
                By submitting your score, you agree to allow us to collect and store your Facebook username and game data for leaderboard and promotional purposes.
            </div>
            
            <button type="button" class="submit-btn" onclick="submitScore()">SUBMIT SCORE</button>
        </form>
        
        <p style="font-size: 11px; color: #888; margin-top: 10px;">
            Complete this form to save your score and compete on the leaderboard!
        </p>
    </div>
    
    <div id="mobile-controls">
        <div id="move-zone" class="control-zone">
            <div class="control-label">MOVE</div>
        </div>
        <div id="shoot-zone" class="control-zone">
            <div class="control-label">SHOOT</div>
        </div>
    </div>

    <script>
        // Game variables
        let player;
        let obstacles = [];
        let powerUps = [];
        let bullets = [];
        let score = 0;
        let level = 8;
        let gameSpeed = 2;
        let gameState = "start";
        let timer;
        let particles = [];
        let lives = 2;
        let bigBooksThisGrade = 0;
        let lastAutoShoot = 0;
        let gradeMessage = "";
        let gradeMessageTimer = 0;
        let showGradeMessage = false;
        let isMobile = false;
        let touchY = null;
        let touchStartY = null;
        let lastShootTime = 0;
        let particleLimit = 20;
        let finalBoss = null;
        let bossProjectiles = [];
        
        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent(document.body);
            player = new Player();
            timer = millis();
            
            // Better mobile detection
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                       (window.innerWidth < 768 && 'ontouchstart' in window);
            
            if (isMobile) {
                particleLimit = 10;
                document.getElementById('mobile-controls').style.display = 'block';
                setupMobileControls();
            }
            
            console.log("Game setup complete! Mobile:", isMobile);
        }
        
        function setupMobileControls() {
            const moveZone = document.getElementById('move-zone');
            const shootZone = document.getElementById('shoot-zone');
            
            // Move controls
            moveZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartY = touch.clientY;
                touchY = touch.clientY;
            });
            
            moveZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchY = touch.clientY;
            });
            
            moveZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchY = null;
                touchStartY = null;
            });
            
            // Shoot controls
            shootZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState === "play") {
                    shoot();
                }
            });
        }
        
        function draw() {
            // Simplified background for mobile
            if (isMobile) {
                background(26, 26, 46);
            } else {
                background(26, 26, 46);
                // Gradient effect only on desktop
                for (let i = 0; i <= height; i += 20) {
                    let inter = map(i, 0, height, 0, 1);
                    let c = lerpColor(color(26, 26, 46), color(16, 16, 36), inter);
                    stroke(c);
                    strokeWeight(1);
                    line(0, i, width, i);
                }
            }
            
            // Update particles with limit
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].show();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }
            
            if (gameState === "start") {
                showStartScreen();
            } else if (gameState === "play") {
                playGame();
            } else if (gameState === "gameover") {
                showGameOver();
            }
        }
        
        function showStartScreen() {
            background(26, 26, 46);
            
            textAlign(CENTER, CENTER);
            fill(255);
            noStroke();
            textSize(min(width * 0.08, 32));
            text("üìö Leamah School Dodge Challenge", width / 2, height / 2 - 80);
            
            textSize(min(width * 0.05, 20));
            fill(200, 200, 255);
            text("Grade 8 - 12 Educational Game", width / 2, height / 2 - 40);
            
            textSize(min(width * 0.045, 18));
            fill(150, 255, 150);
            text("üéØ Dodge desks & chairs", width / 2, height / 2);
            text("üìñ Collect books for points", width / 2, height / 2 + 25);
            
            if (isMobile) {
                text("üì± Left side: Move | Right side: Shoot", width / 2, height / 2 + 50);
            } else {
                text("üöÄ Shoot correct answers", width / 2, height / 2 + 50);
            }
            
            fill(255, 100, 100);
            textSize(min(width * 0.04, 16));
            text("‚ù§Ô∏è You have 2 Lives!", width / 2, height / 2 + 75);
            
            let pulse = sin(millis() * 0.01) * 0.5 + 0.5;
            fill(255, 255, 0, 150 + pulse * 105);
            textSize(min(width * 0.06, 24));
            text("TAP TO START!", width / 2, height / 2 + 120);
        }
        
        function playGame() {
            // Level progression (cap at grade 12)
            if (millis() - timer > 30000 && level < 12) {
                level++;
                gameSpeed = min(2 + (level - 8) * 0.5, 6);
                timer = millis();
                bigBooksThisGrade = 0;
                setGradeMessage(level);
                
                // Spawn boss at grade 12
                if (level === 12 && !finalBoss) {
                    finalBoss = new FinalBoss();
                    gradeMessage = "FINAL BOSS! üëπ";
                    showGradeMessage = true;
                    gradeMessageTimer = millis();
                }
                
                // Fewer particles on mobile
                let particleCount = isMobile ? 10 : 20;
                for (let i = 0; i < particleCount; i++) {
                    addParticle(width / 2, height / 2, color(255, 215, 0));
                }
            }
            
            // Better auto-shoot for mobile
            if (isMobile && millis() - lastAutoShoot > 200) {
                for (let obs of obstacles) {
                    if (obs.x < width * 0.4 && abs(obs.y - player.y) < 80) {
                        shoot();
                        lastAutoShoot = millis();
                        break;
                    }
                }
                // Also auto-shoot at boss
                if (finalBoss && finalBoss.x < width * 0.7) {
                    shoot();
                    lastAutoShoot = millis();
                }
            }
            
            player.update();
            player.show();
            
            // Update and show final boss
            if (finalBoss) {
                finalBoss.update();
                finalBoss.show();
                
                // Check if player hits boss
                if (player.hits(finalBoss)) {
                    lives = 0;
                    gameState = "gameover";
                    
                    let particleCount = isMobile ? 20 : 40;
                    for (let j = 0; j < particleCount; j++) {
                        addParticle(player.x, player.y, color(255, 100, 100));
                    }
                }
            }
            
            // Update boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                bossProjectiles[i].update();
                bossProjectiles[i].show();
                
                if (player.hits(bossProjectiles[i])) {
                    lives--;
                    bossProjectiles.splice(i, 1);
                    
                    let particleCount = isMobile ? 8 : 15;
                    for (let j = 0; j < particleCount; j++) {
                        addParticle(player.x, player.y, color(255, 100, 100));
                    }
                    
                    if (lives <= 0) {
                        gameState = "gameover";
                    } else {
                        gradeMessage = `Lives Left: ${lives} ‚ù§Ô∏è`;
                        showGradeMessage = true;
                        gradeMessageTimer = millis();
                    }
                } else if (bossProjectiles[i] && bossProjectiles[i].offscreen()) {
                    bossProjectiles.splice(i, 1);
                }
            }
            
            // Spawn obstacles (less if boss is present)
            let spawnChance = finalBoss ? 0.008 : (isMobile ? 0.015 : 0.02);
            if (random(1) < spawnChance + level * 0.005) {
                obstacles.push(new Obstacle());
            }
            
            // Spawn power-ups
            if (random(1) < 0.012) {
                powerUps.push(new PowerUp());
            }
            
            // Spawn big books
            if (random(1) < 0.002 && bigBooksThisGrade < 2) {
                powerUps.push(new PowerUp(true));
                bigBooksThisGrade++;
            }
            
            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                obstacles[i].show();
                
                if (player.hits(obstacles[i])) {
                    lives--;
                    obstacles.splice(i, 1);
                    
                    let particleCount = isMobile ? 8 : 15;
                    for (let j = 0; j < particleCount; j++) {
                        addParticle(player.x, player.y, color(255, 100, 100));
                    }
                    
                    if (lives <= 0) {
                        gameState = "gameover";
                    } else {
                        gradeMessage = `Lives Left: ${lives} ‚ù§Ô∏è`;
                        showGradeMessage = true;
                        gradeMessageTimer = millis();
                    }
                    break;
                }
                
                if (obstacles[i] && obstacles[i].offscreen()) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                powerUps[i].update();
                powerUps[i].show();
                
                if (player.collects(powerUps[i])) {
                    if (powerUps[i].isBig) {
                        score += 50;
                        // Clear screen effect
                        for (let obs of obstacles) {
                            let particleCount = isMobile ? 5 : 15;
                            for (let j = 0; j < particleCount; j++) {
                                addParticle(obs.x, obs.y, color(255, 215, 0));
                            }
                        }
                        obstacles = [];
                        bossProjectiles = []; // Clear boss projectiles too
                        
                        let particleCount = isMobile ? 15 : 30;
                        for (let j = 0; j < particleCount; j++) {
                            addParticle(random(width), random(height), color(255, 255, 100));
                        }
                    } else {
                        score += 10;
                    }
                    
                    let particleCount = powerUps[i].isBig ? (isMobile ? 10 : 20) : (isMobile ? 4 : 8);
                    for (let j = 0; j < particleCount; j++) {
                        addParticle(powerUps[i].x, powerUps[i].y, 
                                  powerUps[i].isBig ? color(255, 215, 0) : color(100, 255, 100));
                    }
                    powerUps.splice(i, 1);
                }
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update();
                bullets[i].show();
                
                let bulletHit = false;
                
                // Check hits on boss
                if (finalBoss && bullets[i] && bullets[i].hits(finalBoss)) {
                    finalBoss.takeDamage();
                    bulletHit = true;
                    
                    let particleCount = isMobile ? 5 : 10;
                    for (let k = 0; k < particleCount; k++) {
                        addParticle(finalBoss.x, finalBoss.y, color(255, 150, 0));
                    }
                    
                    if (finalBoss.health <= 0) {
                        // Boss defeated!
                        score += 500;
                        finalBoss = null;
                        
                        gradeMessage = "BOSS DEFEATED! üéâ";
                        showGradeMessage = true;
                        gradeMessageTimer = millis();
                        
                        // Epic explosion
                        let particleCount = isMobile ? 30 : 60;
                        for (let j = 0; j < particleCount; j++) {
                            addParticle(width * 0.7, height / 2, color(random(200, 255), random(100, 255), 0));
                        }
                    }
                }
                
                // Check hits on obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    if (bullets[i] && bullets[i].hits(obstacles[j])) {
                        let particleCount = isMobile ? 5 : 10;
                        for (let k = 0; k < particleCount; k++) {
                            addParticle(obstacles[j].x, obstacles[j].y, color(255, 150, 0));
                        }
                        obstacles.splice(j, 1);
                        bulletHit = true;
                        score += 5;
                        break;
                    }
                }
                
                if (bulletHit || (bullets[i] && bullets[i].offscreen())) {
                    bullets.splice(i, 1);
                }
            }
            
            showGameUI();
            
            if (showGradeMessage) {
                showGradeProgressMessage();
            }
        }
        
        function addParticle(x, y, col) {
            if (particles.length < particleLimit) {
                particles.push(new Particle(x, y, col));
            }
        }
        
        function showGameUI() {
            fill(0, 0, 0, 150);
            noStroke();
            rect(10, 10, min(200, width * 0.4), 100, 10);
            
            fill(255);
            textAlign(LEFT, TOP);
            textSize(min(width * 0.04, 18));
            text("üìä Score: " + score, 20, 30);
            text("üéì Grade: " + level, 20, 50);
            text("‚ö° Speed: " + gameSpeed.toFixed(1), 20, 70);
            
            fill(255, 100, 100);
            text("‚ù§Ô∏è Lives: " + lives, 20, 90);
        }
        
        function showGameOver() {
            background(26, 26, 46);
            
            fill(0, 0, 0, 150);
            noStroke();
            rect(0, 0, width, height);
            
            textAlign(CENTER, CENTER);
            fill(255, 100, 100);
            textSize(min(width * 0.09, 36));
            text("üìö GAME OVER", width / 2, height / 2 - 60);
            
            fill(255);
            textSize(min(width * 0.06, 24));
            text("Final Score: " + score, width / 2, height / 2 - 20);
            text("Grade Reached: " + level, width / 2, height / 2 + 10);
            
            // Show form
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-grade').textContent = level;
            
            document.getElementById('form-overlay').style.display = 'block';
            document.getElementById('data-form').style.display = 'block';
            
            // Stop the game loop to prevent interference
            noLoop();
            
            // Focus on input after a short delay (important for mobile)
            setTimeout(() => {
                const input = document.getElementById('facebook-username');
                if (input) {
                    input.focus();
                    // For iOS devices
                    if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                        input.setAttribute('readonly', 'readonly');
                        setTimeout(() => {
                            input.removeAttribute('readonly');
                            input.focus();
                        }, 100);
                    }
                }
            }, 300);
        }
        
        function setGradeMessage(grade) {
            const messages = {
                8: "Let's Go! üöÄ",
                9: "Wena Na? üòé",
                10: "Eh Eh Eh! üî•",
                11: "Inzinja Madoda! üí™",
                12: "Abashwe! üëë"
            };
            
            gradeMessage = messages[grade] || `Grade ${grade}! üéì`;
            showGradeMessage = true;
            gradeMessageTimer = millis();
        }
        
        function showGradeProgressMessage() {
            if (millis() - gradeMessageTimer > 3000) {
                showGradeMessage = false;
                return;
            }
            
            fill(0, 0, 0, 180);
            noStroke();
            rect(0, 0, width, height);
            
            let elapsed = millis() - gradeMessageTimer;
            let fadeIn = min(elapsed / 500, 1);
            let fadeOut = elapsed > 2500 ? 1 - ((elapsed - 2500) / 500) : 1;
            let alpha = fadeIn * fadeOut * 255;
            
            let pulse = sin(elapsed * 0.01) * 0.3 + 1;
            
            textAlign(CENTER, CENTER);
            fill(255, 215, 0, alpha);
            textSize(min(width * 0.1, 40) * pulse);
            text(gradeMessage, width / 2, height / 2);
            
            fill(255, 255, 255, alpha);
            textSize(min(width * 0.06, 24));
            text(`Grade ${level}`, width / 2, height / 2 + 60);
        }
        
        function mousePressed() {
            if (gameState === "start") {
                gameState = "play";
                timer = millis();
            }
        }
        
        function touchStarted() {
            if (gameState === "start") {
                gameState = "play";
                timer = millis();
            }
            return false;
        }
        
        function keyPressed() {
            if (key === ' ') {
                shoot();
            }
        }
        
        function shoot() {
            if (gameState === "play") {
                // Limit shooting rate
                if (millis() - lastShootTime > 100) {
                    bullets.push(new Bullet(player.x + player.r, player.y));
                    lastShootTime = millis();
                }
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
        
        function restartGame() {
            gameState = "start";
            score = 0;
            level = 8;
            gameSpeed = 2;
            lives = 2;
            obstacles = [];
            powerUps = [];
            bullets = [];
            particles = [];
            player = new Player();
            timer = millis();
            bigBooksThisGrade = 0;
            lastAutoShoot = 0;
            gradeMessage = "";
            gradeMessageTimer = 0;
            showGradeMessage = false;
            finalBoss = null;
            bossProjectiles = [];
            
            document.getElementById('form-overlay').style.display = 'none';
            document.getElementById('data-form').style.display = 'none';
            document.getElementById('facebook-username').value = '';
            
            // Resume the game loop
            loop();
        }
        
        // Global submit function for mobile compatibility
        async function submitScore() {
            const facebookUsername = document.getElementById('facebook-username').value.trim();
            const submitBtn = document.querySelector('.submit-btn');
            
            if (!facebookUsername) {
                alert('Please enter your Facebook username to save your score!');
                return false;
            }
            
            if (facebookUsername.length < 2) {
                alert('Please enter a valid Facebook username!');
                return false;
            }
            
            // Show loading state
            submitBtn.textContent = 'SUBMITTING...';
            submitBtn.disabled = true;
            
            // Create form data
            const formData = new FormData();
            formData.append('form-name', 'game-scores');
            formData.append('facebook-username', facebookUsername);
            formData.append('score', score);
            formData.append('grade', level);
            formData.append('timestamp', new Date().toISOString());
            formData.append('game-session', Date.now());
            
            try {
                // Submit to Netlify
                const response = await fetch('/', {
                    method: 'POST',
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    body: new URLSearchParams(formData).toString()
                });
                
                if (response.ok) {
                    showSuccessMessage();
                } else {
                    throw new Error('Submission failed');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('There was an error submitting your score. Please try again.');
                submitBtn.textContent = 'SUBMIT SCORE';
                submitBtn.disabled = false;
            }
        }
        
        // Handle form submission with JavaScript
        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('score-form');
            const input = document.getElementById('facebook-username');
            const submitBtn = document.querySelector('.submit-btn');
            
            // Prevent canvas from stealing focus
            if (input) {
                input.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                });
                
                input.addEventListener('click', function(e) {
                    e.stopPropagation();
                    this.focus();
                });
                
                // Ensure keyboard shows on mobile
                input.addEventListener('focus', function() {
                    if (isMobile) {
                        document.body.style.position = 'fixed';
                        document.body.style.width = '100%';
                    }
                });
                
                input.addEventListener('blur', function() {
                    if (isMobile) {
                        document.body.style.position = '';
                        document.body.style.width = '';
                    }
                });
            }
            
            // Handle submit button touches
            if (submitBtn) {
                submitBtn.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                });
                
                submitBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Trigger form submission
                    if (form) {
                        form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
                    }
                });
                
                submitBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            if (form) {
                // Prevent default touch handling on form
                form.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                });
                
                form.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const facebookUsername = document.getElementById('facebook-username').value.trim();
                    
                    if (!facebookUsername) {
                        alert('Please enter your Facebook username to save your score!');
                        return false;
                    }
                    
                    if (facebookUsername.length < 2) {
                        alert('Please enter a valid Facebook username!');
                        return false;
                    }
                    
                    // Show loading state
                    submitBtn.textContent = 'SUBMITTING...';
                    submitBtn.disabled = true;
                    
                    // Create form data
                    const formData = new FormData();
                    formData.append('form-name', 'game-scores');
                    formData.append('facebook-username', facebookUsername);
                    formData.append('score', score);
                    formData.append('grade', level);
                    formData.append('timestamp', new Date().toISOString());
                    formData.append('game-session', Date.now());
                    
                    try {
                        // Submit to Netlify
                        const response = await fetch('/', {
                            method: 'POST',
                            headers: { "Content-Type": "application/x-www-form-urlencoded" },
                            body: new URLSearchParams(formData).toString()
                        });
                        
                        if (response.ok) {
                            showSuccessMessage();
                        } else {
                            throw new Error('Submission failed');
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        alert('There was an error submitting your score. Please try again.');
                        submitBtn.textContent = 'SUBMIT SCORE';
                        submitBtn.disabled = false;
                    }
                });
            }
        });
        
        function showSuccessMessage() {
            document.getElementById('form-overlay').style.display = 'block';
            document.getElementById('data-form').style.display = 'none';
            
            const successDiv = document.createElement('div');
            successDiv.innerHTML = `
                <div style="
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(76, 175, 80, 0.95);
                    padding: 40px;
                    border-radius: 15px;
                    text-align: center;
                    color: white;
                    z-index: 35;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    max-width: 400px;
                    width: 90%;
                ">
                    <h2 style="margin: 0 0 20px 0;">üèÜ Score Submitted Successfully!</h2>
                    <p style="margin: 0 0 15px 0; font-size: 18px;">Thank you for playing Leamah School Dodge Challenge!</p>
                    <p style="margin: 0 0 25px 0;">Your score has been recorded and you're now on the leaderboard.</p>
                    <button onclick="restartFromSuccess()" style="
                        background: white;
                        color: #4CAF50;
                        padding: 15px 30px;
                        border: none;
                        border-radius: 8px;
                        font-size: 18px;
                        font-weight: bold;
                        cursor: pointer;
                    ">üéÆ PLAY AGAIN</button>
                </div>
            `;
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                restartFromSuccess();
            }, 5000);
        }
        
        function restartFromSuccess() {
            const successDiv = document.querySelector('div[style*="rgba(76, 175, 80"]');
            if (successDiv && successDiv.parentNode) {
                successDiv.parentNode.removeChild(successDiv);
            }
            
            document.getElementById('form-overlay').style.display = 'none';
            restartGame();
        }
        
        // Game Classes
        class Player {
            constructor() {
                this.x = 80;
                this.y = height / 2;
                this.r = min(25, width * 0.04);
                this.targetY = this.y;
                this.trail = isMobile ? [] : [];
                this.speed = isMobile ? 8 : 6;
            }
            
            update() {
                // Keyboard controls
                if (keyIsDown(UP_ARROW)) {
                    this.targetY -= this.speed;
                }
                if (keyIsDown(DOWN_ARROW)) {
                    this.targetY += this.speed;
                }
                
                // Mobile touch controls
                if (isMobile && touchY !== null && touchStartY !== null) {
                    let delta = (touchStartY - touchY) * 0.5;
                    this.targetY = this.y - delta;
                }
                
                this.y = lerp(this.y, this.targetY, 0.2);
                this.targetY = constrain(this.targetY, this.r, height - this.r - (isMobile ? 150 : 50));
                this.y = constrain(this.y, this.r, height - this.r - (isMobile ? 150 : 50));
                
                // Only show trail on desktop
                if (!isMobile) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) {
                        this.trail.shift();
                    }
                }
            }
            
            show() {
                // Trail only on desktop
                if (!isMobile) {
                    for (let i = 0; i < this.trail.length; i++) {
                        let alpha = map(i, 0, this.trail.length - 1, 0, 255);
                        fill(30, 150, 255, alpha);
                        noStroke();
                        ellipse(this.trail[i].x, this.trail[i].y, (this.r * 2) * (i / this.trail.length));
                    }
                }
                
                fill(30, 150, 255);
                stroke(255);
                strokeWeight(2);
                ellipse(this.x, this.y, this.r * 2);
                
                fill(255);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(this.r * 0.8);
                text("üòä", this.x, this.y);
            }
            
            hits(obj) {
                let hitDistance = (this.r * 0.7) + (obj.r * 0.7);
                return dist(this.x, this.y, obj.x, obj.y) < hitDistance;
            }
            
            collects(obj) {
                let collectDistance = (this.r * 1.2) + (obj.r * 1.2);
                return dist(this.x, this.y, obj.x, obj.y) < collectDistance;
            }
        }
        
        class Obstacle {
            constructor() {
                this.x = width + 30;
                this.y = random(30, height - (isMobile ? 180 : 30));
                this.r = min(25, width * 0.04);
                this.speed = gameSpeed;
                this.type = random() > 0.5 ? 'desk' : 'chair';
            }
            
            update() {
                this.x -= this.speed;
            }
            
            show() {
                fill(200, 50, 50);
                stroke(150, 0, 0);
                strokeWeight(2);
                
                if (this.type === 'desk') {
                    rect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2, 5);
                    fill(255);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(this.r * 0.6);
                    text("üè´", this.x, this.y);
                } else {
                    ellipse(this.x, this.y, this.r * 2);
                    fill(255);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(this.r * 0.6);
                    text("ü™ë", this.x, this.y);
                }
            }
            
            offscreen() {
                return this.x < -this.r;
            }
        }
        
        class PowerUp {
            constructor(isBig = false) {
                this.x = width + 20;
                this.y = random(60, height - (isMobile ? 210 : 60));
                this.isBig = isBig;
                this.r = isBig ? min(35, width * 0.06) : min(20, width * 0.035);
                this.speed = gameSpeed * (isBig ? 0.6 : 0.8);
                this.pulse = 0;
            }
            
            update() {
                this.x -= this.speed;
                this.pulse += 0.1;
            }
            
            show() {
                let size = this.r * 2 + sin(this.pulse) * (this.isBig ? 12 : 8);
                
                if (this.isBig) {
                    // Fewer glow layers on mobile
                    let layers = isMobile ? 2 : 5;
                    for (let i = layers; i > 0; i--) {
                        fill(255, 215, 0, 60 - i * 10);
                        ellipse(this.x, this.y, size + i * 15);
                    }
                    
                    fill(255, 215, 0, 230);
                    stroke(255, 165, 0);
                    strokeWeight(3);
                    ellipse(this.x, this.y, size);
                    
                    fill(255);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(this.r * 0.9);
                    text("üìö", this.x, this.y);
                    
                    fill(255, 255, 255);
                    textSize(this.r * 0.4);
                    text("CLEAR!", this.x, this.y - this.r * 1.5);
                } else {
                    // Fewer glow layers on mobile
                    let layers = isMobile ? 1 : 3;
                    for (let i = layers; i > 0; i--) {
                        fill(50, 255, 50, 80 - i * 20);
                        ellipse(this.x, this.y, size + i * 10);
                    }
                    
                    fill(50, 255, 50, 230);
                    stroke(0, 200, 0);
                    strokeWeight(2);
                    ellipse(this.x, this.y, size);
                    
                    fill(255);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(this.r * 0.8);
                    text("üìñ", this.x, this.y);
                }
            }
            
            offscreen() {
                return this.x < -this.r;
            }
        }
        
        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = min(8, width * 0.015);
                this.speed = min(12, width * 0.025);
            }
            
            update() {
                this.x += this.speed;
            }
            
            show() {
                fill(255, 255, 0);
                stroke(255, 200, 0);
                strokeWeight(2);
                ellipse(this.x, this.y, this.r * 2);
                
                fill(0);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(this.r * 1.2);
                text("‚úì", this.x, this.y);
            }
            
            hits(obj) {
                let hitDistance = this.r + obj.r * 0.8;
                return dist(this.x, this.y, obj.x, obj.y) < hitDistance;
            }
            
            offscreen() {
                return this.x > width + this.r;
            }
        }
        
        class Particle {
            constructor(x, y, col) {
                this.x = x;
                this.y = y;
                this.vx = random(-3, 3);
                this.vy = random(-3, 3);
                this.life = 255;
                this.color = col;
                this.decay = isMobile ? 10 : 5;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            
            show() {
                fill(red(this.color), green(this.color), blue(this.color), this.life);
                noStroke();
                ellipse(this.x, this.y, isMobile ? 6 : 8);
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        class FinalBoss {
            constructor() {
                this.x = width + 100;
                this.y = height / 2;
                this.targetY = height / 2;
                this.r = min(60, width * 0.1);
                this.health = isMobile ? 25 : 30; // Slightly easier on mobile
                this.maxHealth = this.health;
                this.speed = 1.5;
                this.movePattern = 0;
                this.lastShoot = 0;
                this.shootInterval = isMobile ? 1500 : 1200;
                this.pulse = 0;
            }
            
            update() {
                // Move to position
                if (this.x > width * 0.7) {
                    this.x -= this.speed;
                } else {
                    // Vertical movement pattern
                    this.movePattern += 0.02;
                    this.targetY = height / 2 + sin(this.movePattern) * (height * 0.3);
                    this.y = lerp(this.y, this.targetY, 0.05);
                    
                    // Shoot projectiles
                    if (millis() - this.lastShoot > this.shootInterval) {
                        this.shoot();
                        this.lastShoot = millis();
                    }
                }
                
                this.pulse += 0.05;
            }
            
            shoot() {
                // Triple shot pattern
                let angles = [-0.2, 0, 0.2];
                for (let angle of angles) {
                    bossProjectiles.push(new BossProjectile(this.x - this.r, this.y, angle));
                }
                
                // Sometimes shoot a spread
                if (random(1) < 0.3) {
                    for (let i = -2; i <= 2; i++) {
                        bossProjectiles.push(new BossProjectile(this.x - this.r, this.y, i * 0.15));
                    }
                }
            }
            
            show() {
                // Boss glow effect
                let glowSize = this.r * 2.5 + sin(this.pulse) * 20;
                fill(150, 0, 200, 30);
                noStroke();
                ellipse(this.x, this.y, glowSize);
                
                // Boss body
                fill(100, 0, 150);
                stroke(200, 0, 255);
                strokeWeight(4);
                ellipse(this.x, this.y, this.r * 2);
                
                // Boss face
                fill(255);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(this.r * 0.8);
                text("üëπ", this.x, this.y);
                
                // Health bar
                let barWidth = this.r * 2;
                let barHeight = 10;
                let barY = this.y - this.r - 20;
                
                // Health bar background
                fill(50, 0, 0);
                rect(this.x - barWidth/2, barY, barWidth, barHeight, 5);
                
                // Health bar fill
                let healthPercent = this.health / this.maxHealth;
                fill(255 * (1 - healthPercent), 255 * healthPercent, 0);
                rect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight, 5);
                
                // Boss title
                fill(255, 200, 0);
                textSize(min(width * 0.03, 14));
                text("PRINCIPAL BOSS", this.x, barY - 15);
            }
            
            takeDamage() {
                this.health--;
                
                // Flash effect
                for (let i = 0; i < 3; i++) {
                    addParticle(this.x + random(-this.r, this.r), 
                               this.y + random(-this.r, this.r), 
                               color(255, 100, 255));
                }
            }
        }
        
        class BossProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.r = min(12, width * 0.02);
                this.speed = min(5, width * 0.01);
                this.angle = angle;
                this.vx = -this.speed * cos(angle);
                this.vy = this.speed * sin(angle);
                this.rotation = 0;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += 0.2;
            }
            
            show() {
                push();
                translate(this.x, this.y);
                rotate(this.rotation);
                
                // Projectile glow
                fill(255, 0, 100, 100);
                noStroke();
                ellipse(0, 0, this.r * 3);
                
                // Projectile body
                fill(255, 0, 100);
                stroke(255, 100, 150);
                strokeWeight(2);
                rect(-this.r/2, -this.r/2, this.r, this.r, 3);
                
                pop();
            }
            
            offscreen() {
                return this.x < -this.r || this.y < -this.r || this.y > height + this.r;
            }
        }
    </script>
</body>
</html>
